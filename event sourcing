Transactional Resource Management
genelde belli bir RDBMS üzerinde çalışan nadiren harici kaynaklar(Resources) kullanan uygulamalar uzun süredir alışılmış 
yöntemlerle Transactional Resource Management yaparak tutarlılığı(Consistency) sağlamaya çalışır. 
Farklı Resource kullanımında ise yapabildiğimiz en iyi şekilde mevcut transaction context’i ile sync(process/commit/rollback) 
ederek tutarlılığı(Consistency) sağlamaya çalışıyorduk. Örnek olarak alttaki resimi değerlendirebiliriz.

boundend context (https://martinfowler.com/bliki/BoundedContext.html)

Isolation or fault-tolerant is one of the most important goals when designing a Microservices. 
If a system consists of a set of well-isolated Microservices, a failure in one of the Microservices will not affect the whole system. 
For instance, if a Microservices (such as member service) is a core service that a lot of other Microservices depend on, we need to 
think about how to design them to make sure the communication and interaction with the core service is fault-tolerant. 
The bounded context could help, by that I mean, each Microservices (such as messaging service) has its own definition of same model 
(such as member) and keeps / syncs them internally so it uses them without invoking the Microservices. The message broker could be
also used as an intermediate between them when trying to invoke Microservices to change its state, and the data will become consistency 
eventually.

event sourcing (https://docs.aws.amazon.com/whitepapers/latest/microservices-on-aws/distributed-data-management.html)

It’s very common for state changes to affect more than a single microservice. In such cases, 
event sourcing has proven to be a useful pattern. The core idea behind event sourcing is to represent and persist every 
application change as an event record. Instead of persisting application state, data is stored as a stream of events. 
Database transaction logging and version control systems are two well-known examples for event sourcing. Event sourcing has a 
couple of benefits: state can be determined and reconstructed for any point in time. It naturally produces a persistent audit trail 
and also facilitates debugging.

Command Query Responsibility Segregation
